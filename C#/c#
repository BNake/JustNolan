

2. Access level descriptors in method creation meaning?
   Что такое дескрипторы уровня доступа в смысле создания метода?

Класс представляет собой конструкцию , которая позволяет создавать свои собственные пользовательские типы путем группирования переменных других типов, методов и событий. Класс похож на план. Он определяет данные и поведение типа. Если класс не объявлен как статический, клиентский код может использовать его, создавая объекты или экземпляры , назначенные переменной. Переменная остается в памяти, пока все ссылки на нее не выйдут из области видимости. В то время CLR отмечает, что он имеет право на сбор мусора. Если класс объявлен как статический , то в памяти существует только одна копия, а клиентский код может получить доступ к нему только через сам класс, а не переменную экземпляра . Для получения дополнительной информации см.Статические классы и члены статического класса .
В отличие от структур, классы поддерживают наследование , фундаментальную характеристику объектно-ориентированного программирования. Для получения дополнительной информации см. Наследование .
Объявление классов
Классы объявляются с помощью ключевого слова class , как показано в следующем примере:
C #

копия
public class Customer
{
    //Fields, properties, methods and events go here...
}
classКлючевое слово предшествует уровень доступа. Поскольку public используется в этом случае, каждый может создавать объекты из этого класса. Имя класса следует за classключевым словом. Остальная часть определения - это тело класса, где определяются поведение и данные. Поля, свойства, методы и события в классе совместно называются членами класса .
Создание объектов
Хотя они иногда используются взаимозаменяемо, класс и объект - разные вещи. Класс определяет тип объекта, но он не является объектом. Объект представляет собой конкретный объект, основанный на классе, и иногда упоминается как экземпляр класса.
Объекты могут быть созданы с помощью нового ключевого слова, за которым следует имя класса, на котором будет основываться объект, например:
C #

копия
Customer object1 = new Customer();
Когда экземпляр класса создается, ссылка на объект передается обратно программисту. В предыдущем примере object1это ссылка на объект, на котором основана Customer. Эта ссылка относится к новому объекту, но не содержит самих данных объекта. Фактически, вы можете создать ссылку на объект без создания объекта вообще:
C #

копия
Customer object2;
Мы не рекомендуем создавать ссылки на объекты, например, такие, которые не относятся к объекту, потому что попытка доступа к объекту через такую ​​ссылку не будет работать во время выполнения. Однако такая ссылка может быть сделана для обращения к объекту либо путем создания нового объекта, либо путем назначения его существующему объекту, например:
C #

копия
Customer object3 = new Customer();
Customer object4 = object3;
Этот код создает две ссылки на объекты, которые относятся к одному и тому же объекту. Следовательно, любые изменения объекта, которые были сделаны, object3будут отражены в последующих применениях object4. Поскольку объекты, основанные на классах, ссылаются по ссылке, классы называются ссылочными типами.
Наследование класса
Наследование выполняется с помощью деривации , что означает, что класс объявляется с использованием базового класса, из которого он наследует данные и поведение. Базовый класс указывается путем добавления двоеточия и имени базового класса после имени производного класса, например:
C #

копия
public class Manager : Employee
{
    // Employee fields, properties, methods and events are inherited
    // New Manager fields, properties, methods and events go here...
}
Когда класс объявляет базовый класс, он наследует всех членов базового класса, кроме конструкторов. 1
В отличие от C ++, класс в C # может непосредственно наследовать только от одного базового класса. Однако, поскольку базовый класс может сам наследовать от другого класса, класс может косвенно наследовать несколько базовых классов. Кроме того, класс может непосредственно реализовать несколько интерфейсов. Дополнительные сведения см . В разделе Интерфейсы .
Класс может быть объявлен абстрактным . Абстрактный класс содержит абстрактные методы, которые имеют определение подписи, но не имеют реализации. Абстрактные классы не могут быть созданы. Они могут использоваться только через производные классы, реализующие абстрактные методы. Напротив, запечатанный класс не позволяет извлекать из него другие классы. Дополнительные сведения см. В разделе Абстрактные и закрытые классы и члены класса . 2
Определения классов могут быть разделены между различными исходными файлами. Дополнительные сведения см. В разделе Частичные классы и методы .
Описание
В следующем примере определяется открытый класс, содержащий одно поле, метод и специальный метод, называемый конструктором. Дополнительные сведения см . В разделе Конструкторы . Затем класс создается с помощью newключевого слова.
пример
C #

копия
public class Person
{
    // Field
    public string name;

    // Constructor that takes no arguments.
    public Person()
    {
        name = "unknown";
    }

    // Constructor that takes one argument.
    public Person(string nm)
    {
        name = nm;
    }

    // Method
    public void SetName(string newName)
    {
        name = newName;
    }
}
class TestPerson
{
    static void Main()
    {
        // Call the constructor that has no parameters.
        Person person1 = new Person();
        Console.WriteLine(person1.name);

        person1.SetName("John Smith");
        Console.WriteLine(person1.name);

        // Call the constructor that has one parameter.
        Person person2 = new Person("Sarah Jones");
        Console.WriteLine(person2.name);

        // Keep the console window open in debug mode.
        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }
}
// Output:
// unknown
// John Smith
// Sarah Jones
Спецификация языка C #
Для получения дополнительной информации см. Спецификацию языка C # . Спецификация языка является окончательным источником синтаксиса и использования C #.



https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/classes




In the following example, a public class that contains a single field, a method, and a special method called a constructor is defined. For more information, see Constructors. The class is then instantiated with the new keyword.




Access level
Используйте модификаторы доступа, общедоступные , защищенные , внутренние или частные , чтобы указать один из следующих объявленных уровней доступности для членов. +
Объявленная доступность	Имея в виду
public	Доступ не ограничен.
protected	Доступ ограничен содержащим классом или типами, производными от содержащего класса.
internal	Доступ ограничен текущей сборкой.
protected internal	Доступ ограничен текущей сборкой или типами, полученными из содержащего класса.
private	Доступ ограничивается содержащим типом.
private protected	Доступ ограничен содержащим классом или типами, производными от содержащего класса в текущей сборке.
Для члена или типа допускается только один модификатор доступа, за исключением случаев, когда вы используете protected internalили private protectedкомбинации.
Модификаторы доступа не допускаются в пространствах имен. Пространства имен не имеют ограничений доступа.
В зависимости от контекста, в котором происходит объявление члена, допускаются только определенные объявленные возможности. Если в объявлении участника не указан модификатор доступа, используется стандартная доступность.
Типы верхнего уровня, которые не вложены в другие типы, могут иметь только доступ internalили publicдоступность. Доступность по умолчанию для этих типов internal.
Вложенные типы, которые являются членами других типов, могут объявлять о доступности, как указано в следующей таблице.
Члены	Доступность элементов по умолчанию	Разрешенная заявленная доступность члена
enum	public	Никто
class	private	public

		protected

		internal

		private

		protected internal 

		private protected

interface	public	Никто
struct	private	public

		internal

		private
Доступность вложенного типа зависит от его области доступности , которая определяется как объявленной доступностью члена, так и областью доступности непосредственно содержащего типа. Тем не менее, область доступности вложенного типа не может превышать область доступности содержащего типа.




